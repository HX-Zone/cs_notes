### 缓存的收益与成本
#### 收益
- 加速读写
  - CPU 多级Cache、Linux Page Cache加速硬盘读写、浏览器缓存
- 减轻后端负载
  - 使用Redis降低后端MySQL负载
#### 成本
- 数据不一致
  - 缓存层和数据层有时间窗口不一致的问题，与更新策略有关系
- 代码维护成本更高
  - 多了一层缓存逻辑
- 运维成本
  - Redis集群主从等运维
#### 使用场景
- 降低后端负载
  - 对高消耗的SQL：缓存结果
- 加速请求相应
  - 利用Redis优化IO响应时间
- 大量写合并为批量写
  - 计数器Redis累加再写入DB

### 缓存更新策略
- LRU/FIFO算法剔除
  - maxmemory-policy，达到最大内存时的淘汰策略
  - 一致性低
- 超时剔除
  - expire
  - 一致性较差
- 主动更新
  - 代码控制生命周期
  - 一致性好，维护成本高
- 两条建议
  - 低一致性：最大内存和淘汰策略
  - 高一致性：超时剔除和主动更新相结合，最大内存和淘汰策略兜底

### 缓存粒度控制 - 考虑存储多大范围的数据
- 考虑通用性：全量属性
- 考虑占用空间：部分属性
- 考虑代码维护：表面上全量属性更好，但是需要综合考虑。

### 缓存穿透问题
#### 是什么？
- 大量请求不命中缓存，但是存储层也没有，无法建立缓存，cache中一直没有缓存，所以一直访问存储层

#### 问题原因
- 业务代码问题
- 恶意攻击、爬虫等

#### 如何发现
- 监控业务的响应时间
- 监控业务业务返回成功失败
- 监控缓存命中率情况

#### 解决方案
- 缓存空对象：把空的结果也缓存在cache中
  - 问题1：需要更多的key（解决方案：设置过期时间）
  - 问题2：缓存层和存储层数据短期不一致（解决方案：订阅更新事件，主动刷新缓存）
- 布隆过滤器拦截：过滤无效的请求
  - 考虑布隆过滤器的生成时机

### 无底洞问题
#### 是什么
- 加机器节点，性能没有提升

#### 问题原因
- 比如mget/mset，要访问多个节点，网络IO耗时更长
- 数据增长与水平扩展需求矛盾

#### 优化思路
- 优化命令：慢查询
- 减少网络通信次数
- 降低接入成本：客户端长连接、连接池、NIO等

#### 批量查询的方案优缺点
| 方案 |优点|缺点|网络IO次数|
|------|----|----|----|
|串行mget|编程简单，key少时满足需求|大量key的时候请求延迟严重|O(keys)|
|串行IO|编程简单，节点少时满足需求|大量节点时延迟严重|O(nodes)|
|并行IO|利用并行特性，延迟取决于最慢的节点|编程复杂，超时问题难定位|O(max_slow(node))|
|hash_tag|性能最高|读写增加tag维护成本高，tag分布有数据倾斜|O(1)|

### 缓存雪崩问题
#### 问题描述
- 缓存同时过期，请求全部转移到DB，DB瞬时压力过大导致雪崩
  
#### 解决方案
- 缓存失效时间分散
- 通过加锁或者队列的方式控制访问DB的并发数量
- 设置多级缓存
- 缓存层高可用，sentinel、cluster
- 客户端降级
- 提前演练、压测找瓶颈

### 热点key的重建优化
#### 问题描述
- 热点key + 较长的重建时间
- 缓存为空时，高并发同时查询数据源与重建缓存

#### 三个目标
- 减少缓存重建的次数
- 数据尽可能一致
- 减少死锁等问题

#### 两个方法
- 互斥锁
  - 将查询源数据和重建缓存的过程锁起来，其他请求先等待
  - 解决了大量查询与重建的问题
  - 问题：大量请求等待的问题
  - 优点：思路简单、一致性
  - 缺点：代码负责度增加、存在死锁风险
- 提前使用互斥锁
  - 设置两级过期时间，做到提前更新
- 永不过期
  - 缓存不设置过期时间
  - 设置逻辑上过期时间，发地过期时异步第更新缓存
  - 优点：基本杜绝热点key的重建问题
  - 缺点：不保证一致性、逻辑过期时间的维护成本和内存成本
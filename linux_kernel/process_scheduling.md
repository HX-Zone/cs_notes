## 进程调度

### 多任务
1. 非抢占式多任务（`cooperative multitasking`）
   1. 除非进程自己停止，否则将一直执行
   2. 自己主动挂起称为让步（`yielding`）
   3. 进程可能独占系统资源
2. 抢占式多任务（`preemptive multitasking`）---- 比非抢占式更优
   1. 由调度程序决定进程的挂起和执行
   2. 进程在被强制挂起（抢占 `preemption`）前的时间是预设的，叫时间片（timeslice）。
   3. 时间片的管理可以避免系统资源被独占。
   4. 可以设置动态时间片
   5. Linux的“公平”调度并没有采用时间片

### Linux的进程调度
#### O(1)调度程序
- 静态时间片算法 + 运行队列
- 多处理器环境下表现很好
- 响应时间敏感的程序上表现不佳
  
#### `CFS` 完全公平调度算法

### 策略
#### I/O 消耗型和处理器消耗型的进程
- I/O消耗型
  - 大部分时间用来提交I/O请求或者等待I/O请求
  - 在等待I/O时阻塞
- 处理器消耗型
  - 进程多数时间用来执行代码
  - 除非被抢占，否则一直执行
  - 策略会降低其调度频率，但是延长其单次运行时间（高速缓存命中率也会更高）
- 调度策略考虑
  - 进程响应速度（响应时间短）
  - 最大系统利用率（高吞吐量）

#### 进程优先级
- 优先级高的先运行
- 优先级相同的按轮转方式调度
- nice值，越nice调用优先级越低
- 实时优先级，可配置

#### 时间片
- 时间片太长：可能响应过慢
- 时间片太短：进程切换消耗过大
- 很多系统默认时间片10ms。
- Linux CFS 不直接分配时间片，而是与系统负载相关
- 新的可运行程序，CFS判断它是否比当前进程消耗的处理器少，若是则立即抢占

#### 调度策略的活动
文本编辑和音频编码程序，前者是交互型，I/O消耗型，需要及时响应，后者是处理器消耗型；显然前者的时间片占用极少，因此当它ready时，调度器会直接让它抢占资源，而剩余时间可以执行音频编码程序。

### Linux调度算法
#### 调度器类
- 以模块方式提供 - 调度器类（scheduler classes）
- 允许多种动态添加的调度算法并存
- 每个调度器只负责自己范畴内的进程
- `CFS`是针对普通进程的调度类，称为`SCHED_NORMAL`。（`kernel/sched_fair.c`）

#### Unix系统中的进程调度
具有最高优先级的进程将运行得更频繁，也会被赋予更多的时间片（进程运行多少时间）。

#### 公平调度
完全摒弃时间片而是分配给进程一个处理器使用比重。
基于一个简单的理念：进程调度的效果应该如果系统具备一个理想中的完美多任务处理器。每个系统平均地获得处理器时间。
- 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。动态地计算每个进程应该运行的时间。
- CFS引入了每个进程获得的时间片底线，这个底线成为**最小粒度**（默认为`1ms`）。以此来控制切换消耗。


### Linux调度的实现 - CFS
#### 时间记账
1. 调度器实体结构
`<linux/sched.h> struct_sched_entity` （`struct task_struct`的se成员变量）
2. 虚拟实时
`vruntime`记录进程的虚拟运行时间：已经运行了多久 & 还应该运行多久
`kernel/sched_fair.c update_curr()`
#### 进程选择
选择具有最有vruntime值的进程
CFS使用红黑树来组织可运行进程队列，并利用其查找具有最小vruntime值的进程。
1. 挑选下一个任务
`kernel/sched_fair.c __pick_next_entity()`
这个函数本身并不会去便利做到最左子节点，因为已经缓存在rb_leftmost。若找不到下一个任务，则执行`idle`进程
2. 向树中加入进程
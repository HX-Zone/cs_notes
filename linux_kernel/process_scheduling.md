## 进程调度

### 多任务
1. 非抢占式多任务（`cooperative multitasking`）
   1. 除非进程自己停止，否则将一直执行
   2. 自己主动挂起称为让步（`yielding`）
   3. 进程可能独占系统资源
2. 抢占式多任务（`preemptive multitasking`）---- 比非抢占式更优
   1. 由调度程序决定进程的挂起和执行
   2. 进程在被强制挂起（抢占 `preemption`）前的时间是预设的，叫时间片（timeslice）。
   3. 时间片的管理可以避免系统资源被独占。
   4. 可以设置动态时间片
   5. Linux的“公平”调度并没有采用时间片

### Linux的进程调度
#### O(1)调度程序
- 静态时间片算法 + 运行队列
- 多处理器环境下表现很好
- 响应时间敏感的程序上表现不佳
  
#### `CFS` 完全公平调度算法

### 策略
#### I/O 消耗型和处理器消耗型的进程
- I/O消耗型
  - 大部分时间用来提交I/O请求或者等待I/O请求
  - 在等待I/O时阻塞
- 处理器消耗型
  - 进程多数时间用来执行代码
  - 除非被抢占，否则一直执行
  - 策略会降低其调度频率，但是延长其单次运行时间（高速缓存命中率也会更高）
- 调度策略考虑
  - 进程响应速度（响应时间短）
  - 最大系统利用率（高吞吐量）

#### 进程优先级
- 优先级高的先运行
- 优先级相同的按轮转方式调度
- nice值，越nice调用优先级越低
- 实时优先级，可配置

#### 时间片
- 时间片太长：可能响应过慢
- 时间片太短：进程切换消耗过大
- 很多系统默认时间片10ms。
- Linux CFS 不直接分配时间片，而是与系统负载相关
- 新的可运行程序，CFS判断它是否比当前进程消耗的处理器少，若是则立即抢占

#### 调度策略的活动
文本编辑和音频编码程序，前者是交互型，I/O消耗型，需要及时响应，后者是处理器消耗型；显然前者的时间片占用极少，因此当它ready时，调度器会直接让它抢占资源，而剩余时间可以执行音频编码程序。

### Linux调度算法
#### 调度器类
- 以模块方式提供 - 调度器类（scheduler classes）
- 允许多种动态添加的调度算法并存
- 每个调度器只负责自己范畴内的进程
- `CFS`是针对普通进程的调度类，称为`SCHED_NORMAL`。（`kernel/sched_fair.c`）